<template>
  <li
    class="flex h-fit flex-col gap-2 rounded-xl border-[1px] border-solid px-2.5 py-1.5"
    :class="stepClasses"
  >
    <header class="flex w-full items-center justify-between gap-2">
      <h2 class="flex items-center gap-1 text-2xl font-semibold">
        <span
          class="line-clamp-1"
          :class="[props.step.complete ? 'line-through' : '']"
        >
          {{ props.step.name }}
        </span>
      </h2>

      <div class="flex items-center gap-1">
        <span
          v-if="props.step.subSteps.length > 0"
          class="text-sm font-bold"
          :aria-label="`Progress: ${completedSubStepsCount} out of ${props.step.subSteps.length}`"
        >
          {{ `(${completedSubStepsCount}/${props.step.subSteps.length})` }}
        </span>
        <UiCheckbox
          v-model="completeState"
          @toggle="toggleStepCompletenessState"
          :ariaLabel="props.step.name"
          :palette="palette"
        />
      </div>
    </header>

    <UiCustomScroll :palette>
      <ul
        ref="accordionElRef"
        class="flex flex-col gap-1 overflow-auto"
      >
        <li
          v-for="sub in props.step.subSteps"
          :key="sub.id"
        >
          <UserGoalSubStep
            :subStep="sub"
            :palette="palette"
            :stepId="props.step.id"
          />
        </li>
        <div
          v-show="isEnterNewSubStepVisible"
          class="h-8 shrink-0"
        >
          <UiInput
            v-model="newSubStepValue"
            @submit="console.log('submitted')"
            @cancel="cancelAddInputHandler"
            ref="enterNewSubStepRef"
            :icon="'add'"
            :palette
            :label="'Enter new sub step to do'"
            :buttonType="'submit'"
          />
        </div>
      </ul>
    </UiCustomScroll>

    <div class="flex h-9 w-full items-center gap-1">
      <button
        v-if="isExpandable"
        @click="expandBtnClickHandler"
        ref="stepExpandBtnRef"
        class="flex h-full shrink-0 grow cursor-pointer items-center justify-center rounded-tl-lg rounded-bl-lg border-[1px] border-solid"
        :class="stepControlBtnClasses"
        type="button"
      >
        <UiIcon
          :icon="'expand'"
          :palette="palette"
          :rotateDeg="isSubStepsExpanded ? -180 : 0"
        />
      </button>
      <button
        @click="addBtnClickHandler"
        class="flex h-full shrink-0 grow cursor-pointer items-center justify-center border-[1px] border-solid"
        :class="[
          ...stepControlBtnClasses,
          isExpandable
            ? 'rounded-tr-lg rounded-br-lg'
            : 'rounded-tl-lg rounded-tr-lg rounded-br-lg rounded-bl-lg',
        ]"
        type="button"
      >
        <UiIcon
          :icon="'add'"
          :palette="palette"
          :rotateDeg="isEnterNewSubStepVisible ? 45 : 0"
        />
      </button>
    </div>
  </li>
</template>

<script lang="ts" setup>
import COLOR_GENERATED_PALETTES_CLASSES from "~/constants/color/autoGeneratedPalettesClasses";

import useGoalsStore from "~/stores/goals";

import pickPalette from "~/utils/pickPalette";

import useAccordionElement from "~/composables/useAccordionElement";

import { goalIdKey } from "~/components/user/goal/provideInject";

import type { UserGoalStep } from "~~/shared/types/goal";

import UiCheckbox from "~/components/ui/Checkbox/UiCheckbox.vue";
import UiIcon from "~/components/ui/Icon/UiIcon.vue";
import UiCustomScroll from "~/components/ui/CustomScroll/UiCustomScroll.vue";

const UserGoalSubStep = defineAsyncComponent(
  () => import("./UserGoalSubStep.vue")
);

type Props = {
  step: UserGoalStep;
};

const props = defineProps<Props>();
const goalIdInject = inject(goalIdKey);
const store = useGoalsStore();

const palette = pickPalette({
  exclude: ["SLATE", "GRAY", "ZINC", "NEUTRAL", "STONE"],
});
const stepClasses = [
  COLOR_GENERATED_PALETTES_CLASSES[palette].BORDER.DEFAULT,
  COLOR_GENERATED_PALETTES_CLASSES[palette].BG.DEFAULT,
  COLOR_GENERATED_PALETTES_CLASSES[palette].TEXT.DEFAULT,
];

const completedSubStepsCount = computed(() =>
  props.step.subSteps.reduce((c, sub) => c + (sub.complete ? 1 : 0), 0)
);

const completeState = shallowRef(props.step.complete);
function toggleStepCompletenessState(state: boolean) {
  if (goalIdInject === undefined) return;

  store.updateGoalCompleteness(
    {
      goalId: goalIdInject,
      stepId: props.step.id,
    },
    state
  );
}
watch(
  () => props.step.complete,
  (v, o) => {
    if (v !== o) {
      completeState.value = v;
    }
  }
);

const stepExpandBtnRef = useTemplateRef<HTMLButtonElement>("stepExpandBtnRef");
const stepControlBtnClasses = [
  COLOR_GENERATED_PALETTES_CLASSES[palette].BORDER.DEFAULT,
  COLOR_GENERATED_PALETTES_CLASSES[palette].BG.DEFAULT,

  COLOR_GENERATED_PALETTES_CLASSES[palette].BORDER.HOVER,
  COLOR_GENERATED_PALETTES_CLASSES[palette].BG.HOVER,
];

/** Is user step expandable (with sub steps) */
const isExpandable = computed(() => props.step.subSteps.length > 0);
const accordionElRef = useTemplateRef("accordionElRef");
const { expanded: isSubStepsExpanded, y: accordionScrollY } =
  useAccordionElement({
    accordionEl: accordionElRef,
    accordionId: `subSteps_${props.step.id}`,
    ariaLabel: "sub steps",
    maxHeight: 400,
    expandToggleEl: stepExpandBtnRef,
    expanded: false,
  });

const enterNewSubStepRef = useTemplateRef("enterNewSubStepRef");
/** Value of input - new sub step */
const newSubStepValue = shallowRef("");
const isEnterNewSubStepVisible = shallowRef(false);
watch(isEnterNewSubStepVisible, (v) => {
  if (!v) {
    // clear input value if input is hidden
    newSubStepValue.value = "";
  }
});

function expandBtnClickHandler() {
  isSubStepsExpanded.value = !isSubStepsExpanded.value;

  // if sub steps doesn't expanded - we hide input for preventing future rendering when expanding list
  if (!isSubStepsExpanded.value) isEnterNewSubStepVisible.value = false;
}
function addBtnClickHandler() {
  isEnterNewSubStepVisible.value = !isEnterNewSubStepVisible.value;

  // if we click on add button - expand list must be expanded for view input field
  if (!isSubStepsExpanded.value) isSubStepsExpanded.value = true;

  // if expanded list is rendered (that means user clicked add button) - scroll to input field for better UX
  if (isEnterNewSubStepVisible.value) {
    setTimeout(() => {
      accordionScrollY.value += accordionElRef.value?.offsetHeight ?? 0;
      enterNewSubStepRef.value?.focus();
    }, 50);
  }
}
function cancelAddInputHandler() {
  // user dismissed to add new sub step -> hide input field
  isEnterNewSubStepVisible.value = false;
}
</script>

<style scoped></style>
